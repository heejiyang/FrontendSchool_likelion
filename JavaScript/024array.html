<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Array</title>
  </head>
  <body>
    <script>
      // let myObj = {
      //     val1: 10,
      //     val2: 30
      // }

      // let fruit = (["메론", "수박"], ["포도", "체리"]);

      // // 배열안 배열일때 ([].[])
      // let fish = ["정어리", "고등어", "참치"]
      // //일반적 배열 방법 []
      // let myobj = { val1: 10, val2: 30 }
      // //키와 value가 있을때 {}

      let myarry = [];
      let myArray = new Array(5);
      console.log(myArray);

      let myArray2 = new Array(5, 3, 2);
      console.log(myArray2);

      myArray2[0]; //5
      myArray2[0] = 100;
      "hello"[2];
      [1, 2, 3, 4][2] //생성과 동시에 값에 접근할 수 있다.

      // 불변성 immutable
      let val = "hello";
      val[2] = "z";
      console.log(val);

      //존재하지 않는 배열에 접근할 수 있다.
      console.log([1, 2, 3, 4][5]); //undefined

      //unshift() : 맨 앞에서 요소를 추가한다.
      const cafe1 = ['coffee', 'cake', 'tea', 'cookie']
      const count1 = cafe1.unshift('bread');
      // count //5
      // cafe1 //['bread', 'coffee', 'cake', 'tea', 'cookie']

      //shift() : 맨 앞에서 요소를 지운다.
      const cafe2 = ['coffee', 'cake', 'tea', 'cookie']
      const firstElement = cafe2.shift();
      firstElement //'coffee'
      cafe2 //['cake', 'tea', 'cookie']

      //push() : 맨 뒤에서 요소를 추가한다.
      const cafe3 = ['coffee', 'cake', 'tea', 'cookie']
      const count2 = cafe3.push('bread')
      count2 //5
      cafe3 //['coffee', 'cake', 'tea', 'cookie', 'bread']

      //pop() : 맨 뒤에서 요소를 제거한다.
      const cafe4 = ['coffee', 'cake', 'tea', 'cookie']
      cafe4.pop() //'cookie'
      cafe4 //['coffee', 'cake', 'tea']

      //splice() : 특정한 인덱스에 요소를 위치시킬 때, 특정 요소 제거
      const cafe5 = ['coffee', 'cake', 'tea', 'cookie']
      cafe5.splice(1, 0, 'bread')
      cafe5 //['coffee', 'bread', 'cake', 'tea', 'cookie']

      const cafe6 = ['coffee', 'cake', 'tea', 'cookie']
      cafe6.splice(-1, 2, 'bread')
      cafe6 //'coffee', 'cake', 'tea', 'bread']

      const cafe7 = ['coffee', 'cake', 'tea', 'cookie']
      cafe7.splice(1, 2)
      cafe7 //['coffee', 'cookie']

      //slice() : 배열 일부분을 잘라내서 새로운 배열 반환한다.
      const cafe8 = ['coffee', 'cake', 'tea', 'cookie']
      cafe8.slice(1, 3); //['cake', 'tea']
      cafe8.slice(2); //['tea', 'cookie']
      cafe8.slice(-2, -1); //['tea']
      cafe8.slice(0, -2); //['coffee', 'cake']

      // 문제. 물고기가 아닌 것
      let fish = ['정어리', '고등어', '돌고래', '참치', '고래상어', '코끼리'];
      console.log(fish.slice(2,3)); //'돌고래'
      console.log(fish.slice(5)); //'코끼리'

      // reverse() : 순서를 거꾸로 뒤집는다.
      const cafe9 = ['coffee', 'cake', 'tea', 'cookie']
      cafe9.reverse(); //['cookie', 'tea', 'cake', 'coffee']

      //indexOf() : 요소의 인덱스를 찾고 싶을때
      //(왼쪽부터 탐색한다. 처음나온 값의 index를 반환한다.)
      const cafe10 = ['coffee', 'cake', 'tea', 'cookie']
      cafe10.indexOf('tea') //2
      cafe10.indexOf('coffe', 1) //-1
      cafe10.indexOf('bread') //-1 배열에 존재하지 않는 요소를 찾거나 해당 인덱스에서 지정된 요소가 탐색되지 않을 시 -1을 출력

      // isArray() : 인자가 배열인지 확인
      Array.isArray('coffee'); //false
      Array.isArray(false); //false
      Array.isArray([1]); //true

      // join() : 요소들을 연결해 하나의 값으로 만들 때
      const cafe11 = ['coffee', 'cake', 'tea', 'cookie']
      cafe11.join('/') //'coffee/cake/tea/cookie'
      cafe11.join('') //'coffeecaketeacookie'

      const example = ['coffee', null, undefined, 'cake']
      example.join('') //'coffeecake'

      // includes() : 특정 요소가 포함되었는지 확인할 때
      const cafe12 = ['coffee', 'cake', 'tea', 'cookie']
      cafe12.includes('bread'); //false
      cafe12.includes('cake'); //true
      cafe12.includes('cake', -3); //true

      // find() : 하나의 요소라도 조건을 만족하는지 확인할 때(하나만)
      const arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
      arr.find(i => i > 5); //6

      // filter() : 모든 요소가 조건을 만족하는지 확인할 때(전부 다)
      const arr1 = [{
        'name' : 'title1',
        'contents' : 'contents1',
        'dataNum' : 1
      }, {
        'name' : 'title2',
        'contents' : 'contents2',
        'dataNum' : 2
      }, {
        'name' : 'title3',
        'contents' : 'contents3',
        'dataNum' : 3
      }, {
        'name' : 'title4',
        'contents' : 'contents4',
        'dataNum' : 4
      }, {
        'name' : 'title5',
        'contents' : 'contents5',
        'dataNum' : 5
      }];

      arr1.filter(i => i.dataNum > 3);
        // [{'name' : 'title4', 'contents' : 'contents4','dataNum' : 4}, {'name' : 'title5', 'contents' : 'contents5', 'dataNum' : 5}]

      // map() : 각각 요소에 함수를 호출할 때
      //배열 내에 있는 요소에 오름차순으로 접근해서 주어진 함수를 호출한 결과를 모아 새로운 배열을 반환한다.
      // i는 원소들이 하나씩 들어가며 훑어본다
      // 화살표 함수로 나타내면 arr.map((i) => i.name);
      const newArr = arr1.map (function (i) {
        return i.name;
      });
      // 문제 : map메소드를 이용해서 name의 값들을 원소로 하는 새로운 배열을 만들어 봅시다!
      const studentList = [
        {
          id: 1, name: '원범', score: 'great'
        },
        {
          id: 2, name: '김진', score: 'nice'
        },
        {
          id: 3, name: '혜원', score: 'good'
        },
        {
          id: 4, name: '재현', score: 'too cool for school'
        }
      ];
      // const newArray = studentList.map((v) => v.name)
      const myArr = studentList.map (
        function (i) {
          return i.name
        }
      )

      // forEach() : 각각의 요소를 실행하고 싶을 때
      const arr3 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
      // arr3.forEach(i => console.log(i));
      arr3.forEach(function (i){
        return console.log(i);
      });
      // 1
      // 2
      // 3
      // 4
      // 5
      // 6
      // 7
      // 8
      // 9
      // 10

      // concat() : 배열을 합치거나 새로운 요소를 추가할 때
      const cafe13 = ['coffee'];
      cafe13.concat(['cake']); //['coffee', 'cake']
      cafe13.concat(['tea'], 'cookie'); //['coffee', 'tea', 'cookie']

      // sort() : 배열 내 요소를 정렬할 때
      // 유니코드 코드 포인트에 의해 배열 내 요소를 오름차순으로 정렬하는데 이 과정에서 요소를 문자열로 취급해 재정렬
      const arr4 = [3, 4, 1, 2];
      arr4.sort(); //[1, 2, 3, 4]

      const vegetable = ['beet', 'carrot', 'apple'];
      vegetable.sort(); //['apple', 'beet', 'carrot']

      // 숫자 정렬은 적합하지 못하다
      const numbers = [400, 200, 100];
      numbers.sort();

      const numbers2 = [40, 200, 1000000];
      numbers2.sort();

      const arrNum = [13, 9, 10, 2];//전역 공간에 선언되어있다.
      arrNum.sort(); //[10, 13, 2, 9]
      // 숫자 비교할때는 compare function을 넣어줘야한다.
      arrNum.sort(function(a,b) {
        // console.log("a : "+a, "b : "+b);
        console.log(`a : ${a}`, `b : ${b}`);
        //a:9 b:13(음수)[9, 13, 10, 2]
        //a:10 b:9(양수)[9, 13, 10, 2]
        //a:10 b:13(음수)[9, 10, 13, 2]
        //a:10 b:9(양수)[9, 10, 13, 2]
        //a:2 b:10(음수)[9, 2, 10, 13]
        //a:2 b:9(음수)[2, 9, 10, 13]
        return a - b; //[2, 9, 10, 13]
      });

      // if(true) {
      //   let num = 10;
      // }
      
      arrNum.sort(function(a,b) {
        if(a < b) {
          return -1
        } else if(a > b) {
          return 1
        } else {
          return 0
        }
      })
      // data sorting
      const studentList2 = [
        {id: 1, product: '연필', stock: 10 },
        {id: 2, product: '노트', stock: 100 },
        {id: 3, product: '지우개', stock: 5 },
        {id: 4, product: '볼펜', stock: 30 }
      ]
      // studentList2.sort(function (a, b) {
      //   if (a.stock < b.stock) {
      //     return -1
      //   } else if (a.stock > b.stock) {
      //     return 1
      //   } else {
      //     return 0
      //   }
      // })
      studentList2.sort(function (a, b) {
        return a.stock - b.stock;
      })
      console.log(studentList2);

      let arrNum_test = [13, 9, 10, 2];
      [...arrNum_test].sort();

      // 원본이 변경된다.
      let a_test = [1, 2, 3, 4]
      let b_test = a_test
      b[0] = 1000
      a
      // 원본 변경이 없다.
      let a_test1 = [1, 2, 3, 4]
      let b_test1 = [...a_test1]
      b_test1[0] = 1000
      a_test1

      // 애러없이 작동되는 코드
      function sort(key) {
        if (click) {
          click = false;
          var sortedData = jsonData.sort((a, b) =>
              a[key] < b[key] ? -1 : a[key] > b[key] ? 1 : 0
          );
        } else {
          click = true;
          var sortedData = jsonData.sort((a, b) =>
            a[key] > b[key] ? -1 : a[key] < b[key] ? 1 : 0
          );
        }

        let tableBodyData = [];

        for (const iterator of sortedData) {
          tableBodyData.push(`
          <tr>
            <td>${iterator["시·도별(1)"]}</td>
            <td>${iterator["총인구 (명)"]}</td>
            <td>${iterator["1차 접종 누계"]}</td>
            <td>${iterator["2차 접종 누계"]}</td>
            <td>${iterator["1차 접종 퍼센트"]}</td>
            <td>${iterator["2차 접종 퍼센트"]}</td>
          </tr>
        `);
        }

        document.querySelector("#dataTable > tbody").innerHTML =
          tableBodyData.join("");
    }

    // 9 - 13 ==> 음수  ==> [9, 13, 10, 2]
    // 10 - 9 ==> 양수 ==> [9, 13, 10, 2]
    // 10 - 13 ==> 음수 ==> [9, 10, 13, 2]
    // 10 - 9 ==> 양수 ==> [9, 10, 13, 2]
    // 2 - 10 ==> 음수 ==> [9, 2, 10, 13]
    // 2 - 9 ==> 음수 ==> [2, 9, 10, 13]

    // if (true) {
    //     let num = 10;
    // }
    const arrNum2 = [13, 9, 10, 2];
    arrNum2.sort(function (a, b) {
      // return a - b;
      if (a < b) {
        return -1;
      } else if (b < a) {
        return 1;
      } else {
        return 0;
      }
    });

    const studentList3 = [
      { id: 1, product: "연필", stock: 10 },
      { id: 2, product: "노트", stock: 100 },
      { id: 3, product: "지우게", stock: 5 },
      { id: 4, product: "볼팬", stock: 30 },
    ];
    studentList3.sort((a, b) => {
      // if (a.stock < b.stock) {
      //     return -1
      // } else if (b.stock < a.stock) {
      //     return 1
      // } else {
      //     return 0
      // }

      return a.stock - b.stock;
    });
    </script>
  </body>
</html>